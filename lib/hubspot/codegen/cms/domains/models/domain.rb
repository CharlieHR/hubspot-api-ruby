=begin
#Domains

#No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: v3

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 4.3.1

=end

require 'date'

module Hubspot
  module Cms
    module Domains
      class Domain
        attr_accessor :portal_id

        attr_accessor :id

        attr_accessor :created

        attr_accessor :updated

        attr_accessor :domain

        attr_accessor :primary_landing_page

        attr_accessor :primary_email

        attr_accessor :primary_blog

        attr_accessor :primary_blog_post

        attr_accessor :primary_site_page

        attr_accessor :primary_knowledge

        attr_accessor :primary_legacy_page

        attr_accessor :primary_click_tracking

        attr_accessor :full_category_key

        attr_accessor :secondary_to_domain

        attr_accessor :is_resolving

        attr_accessor :is_dns_correct

        attr_accessor :manually_marked_as_resolving

        attr_accessor :consecutive_non_resolving_count

        attr_accessor :ssl_cname

        attr_accessor :is_ssl_enabled

        attr_accessor :is_ssl_only

        attr_accessor :certificate_id

        attr_accessor :ssl_request_id

        attr_accessor :is_used_for_blog_post

        attr_accessor :is_used_for_site_page

        attr_accessor :is_used_for_landing_page

        attr_accessor :is_used_for_email

        attr_accessor :is_used_for_knowledge

        attr_accessor :setup_task_id

        attr_accessor :is_setup_complete

        attr_accessor :set_up_language

        attr_accessor :team_ids

        attr_accessor :actual_cname

        attr_accessor :correct_cname

        attr_accessor :actual_ip

        attr_accessor :apex_resolution_status

        attr_accessor :apex_domain

        attr_accessor :public_suffix

        attr_accessor :apex_ip_addresses

        attr_accessor :site_id

        attr_accessor :brand_id

        attr_accessor :deletable

        attr_accessor :domain_cdn_config

        attr_accessor :setup_info

        attr_accessor :derived_brand_name

        attr_accessor :created_by_id

        attr_accessor :updated_by_id

        attr_accessor :label

        attr_accessor :is_any_primary

        attr_accessor :is_legacy_domain

        attr_accessor :is_internal_domain

        attr_accessor :is_resolving_internal_property

        attr_accessor :is_resolving_ignoring_manually_marked_as_resolving

        attr_accessor :is_used_for_any_content_type

        attr_accessor :is_legacy

        attr_accessor :author_at

        attr_accessor :cos_object_type

        attr_accessor :cdn_purge_embargo_time

        attr_accessor :is_staging_domain

        class EnumAttributeValidator
          attr_reader :datatype
          attr_reader :allowable_values

          def initialize(datatype, allowable_values)
            @allowable_values = allowable_values.map do |value|
              case datatype.to_s
              when /Integer/i
                value.to_i
              when /Float/i
                value.to_f
              else
                value
              end
            end
          end

          def valid?(value)
            !value || allowable_values.include?(value)
          end
        end

        # Attribute mapping from ruby-style variable name to JSON key.
        def self.attribute_map
          {
            :'portal_id' => :'portalId',
            :'id' => :'id',
            :'created' => :'created',
            :'updated' => :'updated',
            :'domain' => :'domain',
            :'primary_landing_page' => :'primaryLandingPage',
            :'primary_email' => :'primaryEmail',
            :'primary_blog' => :'primaryBlog',
            :'primary_blog_post' => :'primaryBlogPost',
            :'primary_site_page' => :'primarySitePage',
            :'primary_knowledge' => :'primaryKnowledge',
            :'primary_legacy_page' => :'primaryLegacyPage',
            :'primary_click_tracking' => :'primaryClickTracking',
            :'full_category_key' => :'fullCategoryKey',
            :'secondary_to_domain' => :'secondaryToDomain',
            :'is_resolving' => :'isResolving',
            :'is_dns_correct' => :'isDnsCorrect',
            :'manually_marked_as_resolving' => :'manuallyMarkedAsResolving',
            :'consecutive_non_resolving_count' => :'consecutiveNonResolvingCount',
            :'ssl_cname' => :'sslCname',
            :'is_ssl_enabled' => :'isSslEnabled',
            :'is_ssl_only' => :'isSslOnly',
            :'certificate_id' => :'certificateId',
            :'ssl_request_id' => :'sslRequestId',
            :'is_used_for_blog_post' => :'isUsedForBlogPost',
            :'is_used_for_site_page' => :'isUsedForSitePage',
            :'is_used_for_landing_page' => :'isUsedForLandingPage',
            :'is_used_for_email' => :'isUsedForEmail',
            :'is_used_for_knowledge' => :'isUsedForKnowledge',
            :'setup_task_id' => :'setupTaskId',
            :'is_setup_complete' => :'isSetupComplete',
            :'set_up_language' => :'setUpLanguage',
            :'team_ids' => :'teamIds',
            :'actual_cname' => :'actualCname',
            :'correct_cname' => :'correctCname',
            :'actual_ip' => :'actualIp',
            :'apex_resolution_status' => :'apexResolutionStatus',
            :'apex_domain' => :'apexDomain',
            :'public_suffix' => :'publicSuffix',
            :'apex_ip_addresses' => :'apexIpAddresses',
            :'site_id' => :'siteId',
            :'brand_id' => :'brandId',
            :'deletable' => :'deletable',
            :'domain_cdn_config' => :'domainCdnConfig',
            :'setup_info' => :'setupInfo',
            :'derived_brand_name' => :'derivedBrandName',
            :'created_by_id' => :'createdById',
            :'updated_by_id' => :'updatedById',
            :'label' => :'label',
            :'is_any_primary' => :'isAnyPrimary',
            :'is_legacy_domain' => :'isLegacyDomain',
            :'is_internal_domain' => :'isInternalDomain',
            :'is_resolving_internal_property' => :'isResolvingInternalProperty',
            :'is_resolving_ignoring_manually_marked_as_resolving' => :'isResolvingIgnoringManuallyMarkedAsResolving',
            :'is_used_for_any_content_type' => :'isUsedForAnyContentType',
            :'is_legacy' => :'isLegacy',
            :'author_at' => :'authorAt',
            :'cos_object_type' => :'cosObjectType',
            :'cdn_purge_embargo_time' => :'cdnPurgeEmbargoTime',
            :'is_staging_domain' => :'isStagingDomain'
          }
        end

        # Attribute type mapping.
        def self.openapi_types
          {
            :'portal_id' => :'Integer',
            :'id' => :'Integer',
            :'created' => :'Integer',
            :'updated' => :'Integer',
            :'domain' => :'String',
            :'primary_landing_page' => :'Boolean',
            :'primary_email' => :'Boolean',
            :'primary_blog' => :'Boolean',
            :'primary_blog_post' => :'Boolean',
            :'primary_site_page' => :'Boolean',
            :'primary_knowledge' => :'Boolean',
            :'primary_legacy_page' => :'Boolean',
            :'primary_click_tracking' => :'Boolean',
            :'full_category_key' => :'String',
            :'secondary_to_domain' => :'String',
            :'is_resolving' => :'Boolean',
            :'is_dns_correct' => :'Boolean',
            :'manually_marked_as_resolving' => :'Boolean',
            :'consecutive_non_resolving_count' => :'Integer',
            :'ssl_cname' => :'String',
            :'is_ssl_enabled' => :'Boolean',
            :'is_ssl_only' => :'Boolean',
            :'certificate_id' => :'Integer',
            :'ssl_request_id' => :'Integer',
            :'is_used_for_blog_post' => :'Boolean',
            :'is_used_for_site_page' => :'Boolean',
            :'is_used_for_landing_page' => :'Boolean',
            :'is_used_for_email' => :'Boolean',
            :'is_used_for_knowledge' => :'Boolean',
            :'setup_task_id' => :'Integer',
            :'is_setup_complete' => :'Boolean',
            :'set_up_language' => :'String',
            :'team_ids' => :'Array<Integer>',
            :'actual_cname' => :'String',
            :'correct_cname' => :'String',
            :'actual_ip' => :'String',
            :'apex_resolution_status' => :'String',
            :'apex_domain' => :'String',
            :'public_suffix' => :'String',
            :'apex_ip_addresses' => :'Array<String>',
            :'site_id' => :'Integer',
            :'brand_id' => :'Integer',
            :'deletable' => :'Boolean',
            :'domain_cdn_config' => :'DomainCdnConfig',
            :'setup_info' => :'DomainSetupInfo',
            :'derived_brand_name' => :'String',
            :'created_by_id' => :'Integer',
            :'updated_by_id' => :'Integer',
            :'label' => :'String',
            :'is_any_primary' => :'Boolean',
            :'is_legacy_domain' => :'Boolean',
            :'is_internal_domain' => :'Boolean',
            :'is_resolving_internal_property' => :'Boolean',
            :'is_resolving_ignoring_manually_marked_as_resolving' => :'Boolean',
            :'is_used_for_any_content_type' => :'Boolean',
            :'is_legacy' => :'Boolean',
            :'author_at' => :'Integer',
            :'cos_object_type' => :'String',
            :'cdn_purge_embargo_time' => :'Integer',
            :'is_staging_domain' => :'Boolean'
          }
        end

        # List of attributes with nullable: true
        def self.openapi_nullable
          Set.new([
          ])
        end

        # Initializes the object
        # @param [Hash] attributes Model attributes in the form of hash
        def initialize(attributes = {})
          if (!attributes.is_a?(Hash))
            fail ArgumentError, "The input argument (attributes) must be a hash in `Hubspot::Cms::Domains::Domain` initialize method"
          end

          # check to see if the attribute exists and convert string to symbol for hash key
          attributes = attributes.each_with_object({}) { |(k, v), h|
            if (!self.class.attribute_map.key?(k.to_sym))
              fail ArgumentError, "`#{k}` is not a valid attribute in `Hubspot::Cms::Domains::Domain`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
            end
            h[k.to_sym] = v
          }

          if attributes.key?(:'portal_id')
            self.portal_id = attributes[:'portal_id']
          end

          if attributes.key?(:'id')
            self.id = attributes[:'id']
          end

          if attributes.key?(:'created')
            self.created = attributes[:'created']
          end

          if attributes.key?(:'updated')
            self.updated = attributes[:'updated']
          end

          if attributes.key?(:'domain')
            self.domain = attributes[:'domain']
          end

          if attributes.key?(:'primary_landing_page')
            self.primary_landing_page = attributes[:'primary_landing_page']
          end

          if attributes.key?(:'primary_email')
            self.primary_email = attributes[:'primary_email']
          end

          if attributes.key?(:'primary_blog')
            self.primary_blog = attributes[:'primary_blog']
          end

          if attributes.key?(:'primary_blog_post')
            self.primary_blog_post = attributes[:'primary_blog_post']
          end

          if attributes.key?(:'primary_site_page')
            self.primary_site_page = attributes[:'primary_site_page']
          end

          if attributes.key?(:'primary_knowledge')
            self.primary_knowledge = attributes[:'primary_knowledge']
          end

          if attributes.key?(:'primary_legacy_page')
            self.primary_legacy_page = attributes[:'primary_legacy_page']
          end

          if attributes.key?(:'primary_click_tracking')
            self.primary_click_tracking = attributes[:'primary_click_tracking']
          end

          if attributes.key?(:'full_category_key')
            self.full_category_key = attributes[:'full_category_key']
          end

          if attributes.key?(:'secondary_to_domain')
            self.secondary_to_domain = attributes[:'secondary_to_domain']
          end

          if attributes.key?(:'is_resolving')
            self.is_resolving = attributes[:'is_resolving']
          end

          if attributes.key?(:'is_dns_correct')
            self.is_dns_correct = attributes[:'is_dns_correct']
          end

          if attributes.key?(:'manually_marked_as_resolving')
            self.manually_marked_as_resolving = attributes[:'manually_marked_as_resolving']
          end

          if attributes.key?(:'consecutive_non_resolving_count')
            self.consecutive_non_resolving_count = attributes[:'consecutive_non_resolving_count']
          end

          if attributes.key?(:'ssl_cname')
            self.ssl_cname = attributes[:'ssl_cname']
          end

          if attributes.key?(:'is_ssl_enabled')
            self.is_ssl_enabled = attributes[:'is_ssl_enabled']
          end

          if attributes.key?(:'is_ssl_only')
            self.is_ssl_only = attributes[:'is_ssl_only']
          end

          if attributes.key?(:'certificate_id')
            self.certificate_id = attributes[:'certificate_id']
          end

          if attributes.key?(:'ssl_request_id')
            self.ssl_request_id = attributes[:'ssl_request_id']
          end

          if attributes.key?(:'is_used_for_blog_post')
            self.is_used_for_blog_post = attributes[:'is_used_for_blog_post']
          end

          if attributes.key?(:'is_used_for_site_page')
            self.is_used_for_site_page = attributes[:'is_used_for_site_page']
          end

          if attributes.key?(:'is_used_for_landing_page')
            self.is_used_for_landing_page = attributes[:'is_used_for_landing_page']
          end

          if attributes.key?(:'is_used_for_email')
            self.is_used_for_email = attributes[:'is_used_for_email']
          end

          if attributes.key?(:'is_used_for_knowledge')
            self.is_used_for_knowledge = attributes[:'is_used_for_knowledge']
          end

          if attributes.key?(:'setup_task_id')
            self.setup_task_id = attributes[:'setup_task_id']
          end

          if attributes.key?(:'is_setup_complete')
            self.is_setup_complete = attributes[:'is_setup_complete']
          end

          if attributes.key?(:'set_up_language')
            self.set_up_language = attributes[:'set_up_language']
          end

          if attributes.key?(:'team_ids')
            if (value = attributes[:'team_ids']).is_a?(Array)
              self.team_ids = value
            end
          end

          if attributes.key?(:'actual_cname')
            self.actual_cname = attributes[:'actual_cname']
          end

          if attributes.key?(:'correct_cname')
            self.correct_cname = attributes[:'correct_cname']
          end

          if attributes.key?(:'actual_ip')
            self.actual_ip = attributes[:'actual_ip']
          end

          if attributes.key?(:'apex_resolution_status')
            self.apex_resolution_status = attributes[:'apex_resolution_status']
          end

          if attributes.key?(:'apex_domain')
            self.apex_domain = attributes[:'apex_domain']
          end

          if attributes.key?(:'public_suffix')
            self.public_suffix = attributes[:'public_suffix']
          end

          if attributes.key?(:'apex_ip_addresses')
            if (value = attributes[:'apex_ip_addresses']).is_a?(Array)
              self.apex_ip_addresses = value
            end
          end

          if attributes.key?(:'site_id')
            self.site_id = attributes[:'site_id']
          end

          if attributes.key?(:'brand_id')
            self.brand_id = attributes[:'brand_id']
          end

          if attributes.key?(:'deletable')
            self.deletable = attributes[:'deletable']
          end

          if attributes.key?(:'domain_cdn_config')
            self.domain_cdn_config = attributes[:'domain_cdn_config']
          end

          if attributes.key?(:'setup_info')
            self.setup_info = attributes[:'setup_info']
          end

          if attributes.key?(:'derived_brand_name')
            self.derived_brand_name = attributes[:'derived_brand_name']
          end

          if attributes.key?(:'created_by_id')
            self.created_by_id = attributes[:'created_by_id']
          end

          if attributes.key?(:'updated_by_id')
            self.updated_by_id = attributes[:'updated_by_id']
          end

          if attributes.key?(:'label')
            self.label = attributes[:'label']
          end

          if attributes.key?(:'is_any_primary')
            self.is_any_primary = attributes[:'is_any_primary']
          end

          if attributes.key?(:'is_legacy_domain')
            self.is_legacy_domain = attributes[:'is_legacy_domain']
          end

          if attributes.key?(:'is_internal_domain')
            self.is_internal_domain = attributes[:'is_internal_domain']
          end

          if attributes.key?(:'is_resolving_internal_property')
            self.is_resolving_internal_property = attributes[:'is_resolving_internal_property']
          end

          if attributes.key?(:'is_resolving_ignoring_manually_marked_as_resolving')
            self.is_resolving_ignoring_manually_marked_as_resolving = attributes[:'is_resolving_ignoring_manually_marked_as_resolving']
          end

          if attributes.key?(:'is_used_for_any_content_type')
            self.is_used_for_any_content_type = attributes[:'is_used_for_any_content_type']
          end

          if attributes.key?(:'is_legacy')
            self.is_legacy = attributes[:'is_legacy']
          end

          if attributes.key?(:'author_at')
            self.author_at = attributes[:'author_at']
          end

          if attributes.key?(:'cos_object_type')
            self.cos_object_type = attributes[:'cos_object_type']
          end

          if attributes.key?(:'cdn_purge_embargo_time')
            self.cdn_purge_embargo_time = attributes[:'cdn_purge_embargo_time']
          end

          if attributes.key?(:'is_staging_domain')
            self.is_staging_domain = attributes[:'is_staging_domain']
          end
        end

        # Show invalid properties with the reasons. Usually used together with valid?
        # @return Array for valid properties with the reasons
        def list_invalid_properties
          invalid_properties = Array.new
          if @portal_id.nil?
            invalid_properties.push('invalid value for "portal_id", portal_id cannot be nil.')
          end

          if @id.nil?
            invalid_properties.push('invalid value for "id", id cannot be nil.')
          end

          if @created.nil?
            invalid_properties.push('invalid value for "created", created cannot be nil.')
          end

          if @updated.nil?
            invalid_properties.push('invalid value for "updated", updated cannot be nil.')
          end

          if @domain.nil?
            invalid_properties.push('invalid value for "domain", domain cannot be nil.')
          end

          if @primary_landing_page.nil?
            invalid_properties.push('invalid value for "primary_landing_page", primary_landing_page cannot be nil.')
          end

          if @primary_email.nil?
            invalid_properties.push('invalid value for "primary_email", primary_email cannot be nil.')
          end

          if @primary_blog.nil?
            invalid_properties.push('invalid value for "primary_blog", primary_blog cannot be nil.')
          end

          if @primary_blog_post.nil?
            invalid_properties.push('invalid value for "primary_blog_post", primary_blog_post cannot be nil.')
          end

          if @primary_site_page.nil?
            invalid_properties.push('invalid value for "primary_site_page", primary_site_page cannot be nil.')
          end

          if @primary_knowledge.nil?
            invalid_properties.push('invalid value for "primary_knowledge", primary_knowledge cannot be nil.')
          end

          if @primary_legacy_page.nil?
            invalid_properties.push('invalid value for "primary_legacy_page", primary_legacy_page cannot be nil.')
          end

          if @primary_click_tracking.nil?
            invalid_properties.push('invalid value for "primary_click_tracking", primary_click_tracking cannot be nil.')
          end

          if @full_category_key.nil?
            invalid_properties.push('invalid value for "full_category_key", full_category_key cannot be nil.')
          end

          if @secondary_to_domain.nil?
            invalid_properties.push('invalid value for "secondary_to_domain", secondary_to_domain cannot be nil.')
          end

          if @is_resolving.nil?
            invalid_properties.push('invalid value for "is_resolving", is_resolving cannot be nil.')
          end

          if @is_dns_correct.nil?
            invalid_properties.push('invalid value for "is_dns_correct", is_dns_correct cannot be nil.')
          end

          if @manually_marked_as_resolving.nil?
            invalid_properties.push('invalid value for "manually_marked_as_resolving", manually_marked_as_resolving cannot be nil.')
          end

          if @consecutive_non_resolving_count.nil?
            invalid_properties.push('invalid value for "consecutive_non_resolving_count", consecutive_non_resolving_count cannot be nil.')
          end

          if @ssl_cname.nil?
            invalid_properties.push('invalid value for "ssl_cname", ssl_cname cannot be nil.')
          end

          if @is_ssl_enabled.nil?
            invalid_properties.push('invalid value for "is_ssl_enabled", is_ssl_enabled cannot be nil.')
          end

          if @is_ssl_only.nil?
            invalid_properties.push('invalid value for "is_ssl_only", is_ssl_only cannot be nil.')
          end

          if @certificate_id.nil?
            invalid_properties.push('invalid value for "certificate_id", certificate_id cannot be nil.')
          end

          if @ssl_request_id.nil?
            invalid_properties.push('invalid value for "ssl_request_id", ssl_request_id cannot be nil.')
          end

          if @is_used_for_blog_post.nil?
            invalid_properties.push('invalid value for "is_used_for_blog_post", is_used_for_blog_post cannot be nil.')
          end

          if @is_used_for_site_page.nil?
            invalid_properties.push('invalid value for "is_used_for_site_page", is_used_for_site_page cannot be nil.')
          end

          if @is_used_for_landing_page.nil?
            invalid_properties.push('invalid value for "is_used_for_landing_page", is_used_for_landing_page cannot be nil.')
          end

          if @is_used_for_email.nil?
            invalid_properties.push('invalid value for "is_used_for_email", is_used_for_email cannot be nil.')
          end

          if @is_used_for_knowledge.nil?
            invalid_properties.push('invalid value for "is_used_for_knowledge", is_used_for_knowledge cannot be nil.')
          end

          if @setup_task_id.nil?
            invalid_properties.push('invalid value for "setup_task_id", setup_task_id cannot be nil.')
          end

          if @is_setup_complete.nil?
            invalid_properties.push('invalid value for "is_setup_complete", is_setup_complete cannot be nil.')
          end

          if @set_up_language.nil?
            invalid_properties.push('invalid value for "set_up_language", set_up_language cannot be nil.')
          end

          if @team_ids.nil?
            invalid_properties.push('invalid value for "team_ids", team_ids cannot be nil.')
          end

          if @actual_cname.nil?
            invalid_properties.push('invalid value for "actual_cname", actual_cname cannot be nil.')
          end

          if @correct_cname.nil?
            invalid_properties.push('invalid value for "correct_cname", correct_cname cannot be nil.')
          end

          if @actual_ip.nil?
            invalid_properties.push('invalid value for "actual_ip", actual_ip cannot be nil.')
          end

          if @apex_resolution_status.nil?
            invalid_properties.push('invalid value for "apex_resolution_status", apex_resolution_status cannot be nil.')
          end

          if @apex_domain.nil?
            invalid_properties.push('invalid value for "apex_domain", apex_domain cannot be nil.')
          end

          if @public_suffix.nil?
            invalid_properties.push('invalid value for "public_suffix", public_suffix cannot be nil.')
          end

          if @apex_ip_addresses.nil?
            invalid_properties.push('invalid value for "apex_ip_addresses", apex_ip_addresses cannot be nil.')
          end

          if @site_id.nil?
            invalid_properties.push('invalid value for "site_id", site_id cannot be nil.')
          end

          if @brand_id.nil?
            invalid_properties.push('invalid value for "brand_id", brand_id cannot be nil.')
          end

          if @deletable.nil?
            invalid_properties.push('invalid value for "deletable", deletable cannot be nil.')
          end

          if @domain_cdn_config.nil?
            invalid_properties.push('invalid value for "domain_cdn_config", domain_cdn_config cannot be nil.')
          end

          if @setup_info.nil?
            invalid_properties.push('invalid value for "setup_info", setup_info cannot be nil.')
          end

          if @derived_brand_name.nil?
            invalid_properties.push('invalid value for "derived_brand_name", derived_brand_name cannot be nil.')
          end

          if @created_by_id.nil?
            invalid_properties.push('invalid value for "created_by_id", created_by_id cannot be nil.')
          end

          if @updated_by_id.nil?
            invalid_properties.push('invalid value for "updated_by_id", updated_by_id cannot be nil.')
          end

          if @label.nil?
            invalid_properties.push('invalid value for "label", label cannot be nil.')
          end

          if @is_any_primary.nil?
            invalid_properties.push('invalid value for "is_any_primary", is_any_primary cannot be nil.')
          end

          if @is_legacy_domain.nil?
            invalid_properties.push('invalid value for "is_legacy_domain", is_legacy_domain cannot be nil.')
          end

          if @is_internal_domain.nil?
            invalid_properties.push('invalid value for "is_internal_domain", is_internal_domain cannot be nil.')
          end

          if @is_resolving_internal_property.nil?
            invalid_properties.push('invalid value for "is_resolving_internal_property", is_resolving_internal_property cannot be nil.')
          end

          if @is_resolving_ignoring_manually_marked_as_resolving.nil?
            invalid_properties.push('invalid value for "is_resolving_ignoring_manually_marked_as_resolving", is_resolving_ignoring_manually_marked_as_resolving cannot be nil.')
          end

          if @is_used_for_any_content_type.nil?
            invalid_properties.push('invalid value for "is_used_for_any_content_type", is_used_for_any_content_type cannot be nil.')
          end

          if @is_legacy.nil?
            invalid_properties.push('invalid value for "is_legacy", is_legacy cannot be nil.')
          end

          if @author_at.nil?
            invalid_properties.push('invalid value for "author_at", author_at cannot be nil.')
          end

          if @cos_object_type.nil?
            invalid_properties.push('invalid value for "cos_object_type", cos_object_type cannot be nil.')
          end

          if @cdn_purge_embargo_time.nil?
            invalid_properties.push('invalid value for "cdn_purge_embargo_time", cdn_purge_embargo_time cannot be nil.')
          end

          if @is_staging_domain.nil?
            invalid_properties.push('invalid value for "is_staging_domain", is_staging_domain cannot be nil.')
          end

          invalid_properties
        end

        # Check to see if the all the properties in the model are valid
        # @return true if the model is valid
        def valid?
          return false if @portal_id.nil?
          return false if @id.nil?
          return false if @created.nil?
          return false if @updated.nil?
          return false if @domain.nil?
          return false if @primary_landing_page.nil?
          return false if @primary_email.nil?
          return false if @primary_blog.nil?
          return false if @primary_blog_post.nil?
          return false if @primary_site_page.nil?
          return false if @primary_knowledge.nil?
          return false if @primary_legacy_page.nil?
          return false if @primary_click_tracking.nil?
          return false if @full_category_key.nil?
          return false if @secondary_to_domain.nil?
          return false if @is_resolving.nil?
          return false if @is_dns_correct.nil?
          return false if @manually_marked_as_resolving.nil?
          return false if @consecutive_non_resolving_count.nil?
          return false if @ssl_cname.nil?
          return false if @is_ssl_enabled.nil?
          return false if @is_ssl_only.nil?
          return false if @certificate_id.nil?
          return false if @ssl_request_id.nil?
          return false if @is_used_for_blog_post.nil?
          return false if @is_used_for_site_page.nil?
          return false if @is_used_for_landing_page.nil?
          return false if @is_used_for_email.nil?
          return false if @is_used_for_knowledge.nil?
          return false if @setup_task_id.nil?
          return false if @is_setup_complete.nil?
          return false if @set_up_language.nil?
          return false if @team_ids.nil?
          return false if @actual_cname.nil?
          return false if @correct_cname.nil?
          return false if @actual_ip.nil?
          return false if @apex_resolution_status.nil?
          apex_resolution_status_validator = EnumAttributeValidator.new('String', ["INELIGIBLE", "SUGGEST_RESOLVING", "ALREADY_RESOLVING", "ERROR"])
          return false unless apex_resolution_status_validator.valid?(@apex_resolution_status)
          return false if @apex_domain.nil?
          return false if @public_suffix.nil?
          return false if @apex_ip_addresses.nil?
          return false if @site_id.nil?
          return false if @brand_id.nil?
          return false if @deletable.nil?
          return false if @domain_cdn_config.nil?
          return false if @setup_info.nil?
          return false if @derived_brand_name.nil?
          return false if @created_by_id.nil?
          return false if @updated_by_id.nil?
          return false if @label.nil?
          return false if @is_any_primary.nil?
          return false if @is_legacy_domain.nil?
          return false if @is_internal_domain.nil?
          return false if @is_resolving_internal_property.nil?
          return false if @is_resolving_ignoring_manually_marked_as_resolving.nil?
          return false if @is_used_for_any_content_type.nil?
          return false if @is_legacy.nil?
          return false if @author_at.nil?
          return false if @cos_object_type.nil?
          cos_object_type_validator = EnumAttributeValidator.new('String', ["CONTENT", "EXTENSION_RESOURCE", "LAYOUT", "CUSTOM_WIDGET", "WIDGET", "FORM", "PLACEMENT", "IMAGE", "DOMAIN_SETTINGS", "SITE_SETTINGS", "EMAIL_ADDRESS", "WORKFLOW", "HUBDB_TABLE", "REDIRECT_URL", "DESIGN_FOLDER", "SITE_MAP", "DOMAIN", "BLOG", "FILE", "FOLDER", "SITE_MENU", "THEME", "CONTENT_GROUP", "FOLLOW_ME", "KNOWLEDGE_BASE", "LIST_MEMBERSHIP", "CONTACT_MEMBERSHIP", "PASSWORD_PROTECTED", "UNRESTRICTED_ACCESS", "MARKETPLACE_LISTING", "LAYOUT_SECTION", "THEME_SETTINGS", "VIDEO_PLAYER", "URL_MAPPING", "KNOWLEDGE_CATEGORY", "KNOWLEDGE_HOMEPAGE_CATEGORY", "RAW_ASSET", "GLOBAL_CONTENT", "HUBDB_TABLE_ROW", "BLOG_AUTHOR", "SERVERLESS_FUNCTION", "KNOWLEDGE_CATEGORY_TRANSLATION"])
          return false unless cos_object_type_validator.valid?(@cos_object_type)
          return false if @cdn_purge_embargo_time.nil?
          return false if @is_staging_domain.nil?
          true
        end

        # Custom attribute writer method checking allowed values (enum).
        # @param [Object] apex_resolution_status Object to be assigned
        def apex_resolution_status=(apex_resolution_status)
          validator = EnumAttributeValidator.new('String', ["INELIGIBLE", "SUGGEST_RESOLVING", "ALREADY_RESOLVING", "ERROR"])
          unless validator.valid?(apex_resolution_status)
            fail ArgumentError, "invalid value for \"apex_resolution_status\", must be one of #{validator.allowable_values}."
          end
          @apex_resolution_status = apex_resolution_status
        end

        # Custom attribute writer method checking allowed values (enum).
        # @param [Object] cos_object_type Object to be assigned
        def cos_object_type=(cos_object_type)
          validator = EnumAttributeValidator.new('String', ["CONTENT", "EXTENSION_RESOURCE", "LAYOUT", "CUSTOM_WIDGET", "WIDGET", "FORM", "PLACEMENT", "IMAGE", "DOMAIN_SETTINGS", "SITE_SETTINGS", "EMAIL_ADDRESS", "WORKFLOW", "HUBDB_TABLE", "REDIRECT_URL", "DESIGN_FOLDER", "SITE_MAP", "DOMAIN", "BLOG", "FILE", "FOLDER", "SITE_MENU", "THEME", "CONTENT_GROUP", "FOLLOW_ME", "KNOWLEDGE_BASE", "LIST_MEMBERSHIP", "CONTACT_MEMBERSHIP", "PASSWORD_PROTECTED", "UNRESTRICTED_ACCESS", "MARKETPLACE_LISTING", "LAYOUT_SECTION", "THEME_SETTINGS", "VIDEO_PLAYER", "URL_MAPPING", "KNOWLEDGE_CATEGORY", "KNOWLEDGE_HOMEPAGE_CATEGORY", "RAW_ASSET", "GLOBAL_CONTENT", "HUBDB_TABLE_ROW", "BLOG_AUTHOR", "SERVERLESS_FUNCTION", "KNOWLEDGE_CATEGORY_TRANSLATION"])
          unless validator.valid?(cos_object_type)
            fail ArgumentError, "invalid value for \"cos_object_type\", must be one of #{validator.allowable_values}."
          end
          @cos_object_type = cos_object_type
        end

        # Checks equality by comparing each attribute.
        # @param [Object] Object to be compared
        def ==(o)
          return true if self.equal?(o)
          self.class == o.class &&
              portal_id == o.portal_id &&
              id == o.id &&
              created == o.created &&
              updated == o.updated &&
              domain == o.domain &&
              primary_landing_page == o.primary_landing_page &&
              primary_email == o.primary_email &&
              primary_blog == o.primary_blog &&
              primary_blog_post == o.primary_blog_post &&
              primary_site_page == o.primary_site_page &&
              primary_knowledge == o.primary_knowledge &&
              primary_legacy_page == o.primary_legacy_page &&
              primary_click_tracking == o.primary_click_tracking &&
              full_category_key == o.full_category_key &&
              secondary_to_domain == o.secondary_to_domain &&
              is_resolving == o.is_resolving &&
              is_dns_correct == o.is_dns_correct &&
              manually_marked_as_resolving == o.manually_marked_as_resolving &&
              consecutive_non_resolving_count == o.consecutive_non_resolving_count &&
              ssl_cname == o.ssl_cname &&
              is_ssl_enabled == o.is_ssl_enabled &&
              is_ssl_only == o.is_ssl_only &&
              certificate_id == o.certificate_id &&
              ssl_request_id == o.ssl_request_id &&
              is_used_for_blog_post == o.is_used_for_blog_post &&
              is_used_for_site_page == o.is_used_for_site_page &&
              is_used_for_landing_page == o.is_used_for_landing_page &&
              is_used_for_email == o.is_used_for_email &&
              is_used_for_knowledge == o.is_used_for_knowledge &&
              setup_task_id == o.setup_task_id &&
              is_setup_complete == o.is_setup_complete &&
              set_up_language == o.set_up_language &&
              team_ids == o.team_ids &&
              actual_cname == o.actual_cname &&
              correct_cname == o.correct_cname &&
              actual_ip == o.actual_ip &&
              apex_resolution_status == o.apex_resolution_status &&
              apex_domain == o.apex_domain &&
              public_suffix == o.public_suffix &&
              apex_ip_addresses == o.apex_ip_addresses &&
              site_id == o.site_id &&
              brand_id == o.brand_id &&
              deletable == o.deletable &&
              domain_cdn_config == o.domain_cdn_config &&
              setup_info == o.setup_info &&
              derived_brand_name == o.derived_brand_name &&
              created_by_id == o.created_by_id &&
              updated_by_id == o.updated_by_id &&
              label == o.label &&
              is_any_primary == o.is_any_primary &&
              is_legacy_domain == o.is_legacy_domain &&
              is_internal_domain == o.is_internal_domain &&
              is_resolving_internal_property == o.is_resolving_internal_property &&
              is_resolving_ignoring_manually_marked_as_resolving == o.is_resolving_ignoring_manually_marked_as_resolving &&
              is_used_for_any_content_type == o.is_used_for_any_content_type &&
              is_legacy == o.is_legacy &&
              author_at == o.author_at &&
              cos_object_type == o.cos_object_type &&
              cdn_purge_embargo_time == o.cdn_purge_embargo_time &&
              is_staging_domain == o.is_staging_domain
        end

        # @see the `==` method
        # @param [Object] Object to be compared
        def eql?(o)
          self == o
        end

        # Calculates hash code according to all attributes.
        # @return [Integer] Hash code
        def hash
          [portal_id, id, created, updated, domain, primary_landing_page, primary_email, primary_blog, primary_blog_post, primary_site_page, primary_knowledge, primary_legacy_page, primary_click_tracking, full_category_key, secondary_to_domain, is_resolving, is_dns_correct, manually_marked_as_resolving, consecutive_non_resolving_count, ssl_cname, is_ssl_enabled, is_ssl_only, certificate_id, ssl_request_id, is_used_for_blog_post, is_used_for_site_page, is_used_for_landing_page, is_used_for_email, is_used_for_knowledge, setup_task_id, is_setup_complete, set_up_language, team_ids, actual_cname, correct_cname, actual_ip, apex_resolution_status, apex_domain, public_suffix, apex_ip_addresses, site_id, brand_id, deletable, domain_cdn_config, setup_info, derived_brand_name, created_by_id, updated_by_id, label, is_any_primary, is_legacy_domain, is_internal_domain, is_resolving_internal_property, is_resolving_ignoring_manually_marked_as_resolving, is_used_for_any_content_type, is_legacy, author_at, cos_object_type, cdn_purge_embargo_time, is_staging_domain].hash
        end

        # Builds the object from hash
        # @param [Hash] attributes Model attributes in the form of hash
        # @return [Object] Returns the model itself
        def self.build_from_hash(attributes)
          new.build_from_hash(attributes)
        end

        # Builds the object from hash
        # @param [Hash] attributes Model attributes in the form of hash
        # @return [Object] Returns the model itself
        def build_from_hash(attributes)
          return nil unless attributes.is_a?(Hash)
          self.class.openapi_types.each_pair do |key, type|
            if type =~ /\AArray<(.*)>/i
              # check to ensure the input is an array given that the attribute
              # is documented as an array but the input is not
              if attributes[self.class.attribute_map[key]].is_a?(Array)
                self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
              end
            elsif !attributes[self.class.attribute_map[key]].nil?
              self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
            end # or else data not found in attributes(hash), not an issue as the data can be optional
          end

          self
        end

        # Deserializes the data based on type
        # @param string type Data type
        # @param string value Value to be deserialized
        # @return [Object] Deserialized data
        def _deserialize(type, value)
          case type.to_sym
          when :DateTime
            DateTime.parse(value)
          when :Date
            Date.parse(value)
          when :String
            value.to_s
          when :Integer
            value.to_i
          when :Float
            value.to_f
          when :Boolean
            if value.to_s =~ /\A(true|t|yes|y|1)\z/i
              true
            else
              false
            end
          when :Object
            # generic object (usually a Hash), return directly
            value
          when /\AArray<(?<inner_type>.+)>\z/
            inner_type = Regexp.last_match[:inner_type]
            value.map { |v| _deserialize(inner_type, v) }
          when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
            k_type = Regexp.last_match[:k_type]
            v_type = Regexp.last_match[:v_type]
            {}.tap do |hash|
              value.each do |k, v|
                hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
              end
            end
          else # model
            Hubspot::Cms::Domains.const_get(type).build_from_hash(value)
          end
        end

        # Returns the string representation of the object
        # @return [String] String presentation of the object
        def to_s
          to_hash.to_s
        end

        # to_body is an alias to to_hash (backward compatibility)
        # @return [Hash] Returns the object in the form of hash
        def to_body
          to_hash
        end

        # Returns the object in the form of hash
        # @return [Hash] Returns the object in the form of hash
        def to_hash
          hash = {}
          self.class.attribute_map.each_pair do |attr, param|
            value = self.send(attr)
            if value.nil?
              is_nullable = self.class.openapi_nullable.include?(attr)
              next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
            end
            
            hash[param] = _to_hash(value)
          end
          hash
        end

        # Outputs non-array value in the form of hash
        # For object, use to_hash. Otherwise, just return the value
        # @param [Object] value Any valid value
        # @return [Hash] Returns the value in the form of hash
        def _to_hash(value)
          if value.is_a?(Array)
            value.compact.map { |v| _to_hash(v) }
          elsif value.is_a?(Hash)
            {}.tap do |hash|
              value.each { |k, v| hash[k] = _to_hash(v) }
            end
          elsif value.respond_to? :to_hash
            value.to_hash
          else
            value
          end
        end
      end
    end
  end
end
